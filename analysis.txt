On average (mean over 5 iterations each), as measured on an Ubuntu
virtual machine on a Macbook Air on random datasets generated by gensort,
the algorithms and languages perform as follows:

Python - Heapsort
  98kB file - CPU time: 0.03, realtime: 0.09, CPU usage: 42%,
              maximum resident set size: 8232kB
  977kB file - CPU time: 0.10, realtime: 0.20, CPU usage: 55%,
               maximum resident set size: 9421kB
  9.6M file - CPU time: 1.07, realtime: 1.24, CPU usage: 86%,
              maximum resident set size: 41898kB
  48M file - CPU time: 6.61, realtime: 7.21, CPU usage: 91%,
             maximum resident set size: 181122kB

Python - Quicksort
  98kB file - CPU time: 0.03, realtime: 0.09, CPU usage: 40%,
              maximum resident set size: 8232kB
  977kB file - CPU time: 0.07, realtime: 0.14, CPU usage: 50%, 
               maximum resident set size: 9420kB
  9.6M file - CPU time: 0.48, realtime: 0.62, CPU usage: 79%,
              maximum resident set size: 42016kB
  48M file - CPU time: 2.88, realtime: 3.05, CPU usage: 94%,
             maximum resident set size: 181039kB

Go - Heapsort
  98kB file - CPU time: 0.00, realtime: 0.01, CPU usage: 41%,
              maximum resident set size: 2036kB
  977kB file - CPU time: 0.01, realtime: 0.04, CPU usage: 46%,
               maximum resident set size: 6519kB
  9.6M file - CPU time: 0.25, realtime: 0.36, CPU usage: 69%,
              maximum resident set size: 57189kB
  48M file - CPU time: 1.69, realtime: 1.91, CPU usage: 88%,
             maximum resident set size: 263028kB

Go - Quicksort
  98kB file - CPU time: 0.00, realtime: 0.01, CPU usage: 34%,
              maximum resident set size: 2040kB
  977kB file - CPU time: 0.01, realtime: 0.04, CPU usage: 38%,
               maximum resident set size: 6521kB
  9.6M file - CPU time: 0.17, realtime: 0.26, CPU usage: 66%,
              maximum resident set size: 57189kB
  48M file - CPU time: 0.96, realtime: 1.22, CPU usage: 78%,
             maximum resident set size: 263030kB

As file sizes get larger, it appears that the Go processes use more
memory (resident set size) than the Python processes. That the reverse
is true for smaller files indicates that Python may have more of a
memory overhead, just for starting up.

As file sizes get larger, the percentage of time spent in overhead (such
as loading the standard libraries, as opposed to actually spent sorting data)
becomes smaller. This also explains why CPU usage is higher with larger files.

Despite the greater memory usage by the Go implementations, it appears
that the Go versions run faster than their Python counterparts, both
in terms of CPU time (user plus system time) and realtime.

Although the Quicksort and Heapsort algorithms utilize approximately
the same amount of memory, Quicksort does perform significantly better
in terms of time.

Both algorithms sort arrays in-place, and both have average n(log(n)) performance
(although Quicksort has the occasional worst-case n**2 performance problem.
Nonetheless, as shown empirically here and in other literature, Quicksort has
better performance in the average case with random data.

It's often said that Quicksort is faster than Heapsort in practice because
the coefficients (which are ignored in complexity analysis) are smaller, but
there's also the matter of CPU caches.

With Quicksort, comparisons are made between array items located near to
each other in memory, which takes advantage of CPU caches. With Heapsort,
comparisons are made between items scattered throughout the array, and thus
can't take advantage of caching.
